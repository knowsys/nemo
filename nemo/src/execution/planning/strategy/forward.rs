//! This module defines the strategy for the (forward) execution of rules.

use crate::{
    error::Error,
    execution::planning::{
        RuntimeInformation, VariableTranslation,
        analysis::variable_order::VariableOrder,
        normalization::rule::NormalizedRule,
        operations::aggregation::GeneratorAggregation,
        strategy::forward::{body::StrategyBody, head::StrategyHead},
    },
    io::ImportManager,
    rule_model::components::tag::Tag,
    table_manager::{SubtableExecutionPlan, TableManager},
};

pub mod body;
pub mod head;
pub mod restricted;

/// Strategy for creating an execution for the
/// (forward) evaluation of a rule.
#[derive(Debug)]
pub struct StrategyForward {
    /// Generator for the body operations
    body: StrategyBody,
    /// Generator for the aggregation
    aggregation: Option<GeneratorAggregation>,
    /// Generator for the head operations
    head: StrategyHead,

    /// Variable translation
    translation: VariableTranslation,
}

impl StrategyForward {
    /// Create a new [StrategyForward].
    pub fn new(rule: &NormalizedRule) -> Self {
        let positive = rule.positive().clone();
        let negative = rule.negative().clone();
        let mut operations = rule.operations().clone();
        let positive_imports = rule.positive_imports().clone();
        let negative_imports = rule.negative_imports().clone();

        let order = rule.variable_order();
        let frontier = rule.frontier();
        let rule_id = rule.id();
        let is_existential = rule.is_existential();
        let aggregation_index = rule.aggregate_index();

        let body = StrategyBody::new(
            order.clone(),
            positive,
            negative,
            positive_imports,
            negative_imports,
            &mut operations,
        );

        body.output_variables();

        let aggregation = rule.aggregate().cloned().map(|aggregation| {
            GeneratorAggregation::new(body.output_variables(), aggregation, &mut operations)
        });

        let mut translation = VariableTranslation::new();
        for variable in rule.variables() {
            translation.add_marker(variable.clone());
        }
        if is_existential {
            // We need to account for new variables generated by the restricted strategy
            for variable in rule
                .normalize_existential_head(&mut VariableOrder::default())
                .0
                .iter()
                .flat_map(|atom| atom.terms())
            {
                translation.add_marker(variable.clone());
            }
        }

        let head = StrategyHead::new(
            rule,
            order,
            frontier,
            aggregation_index,
            rule_id,
            is_existential,
        );

        Self {
            body,
            aggregation,
            head,
            translation,
        }
    }

    /// Return an iterator over all special predicates needed to execute this strategy.
    pub fn special_predicates(&self) -> impl Iterator<Item = (Tag, usize)> {
        self.body
            .special_predicates()
            .chain(self.head.special_predicates())
    }

    /// Create and execute the execution plan defined by this strategy.
    pub async fn execute<'a>(
        &self,
        table_manager: &'a mut TableManager,
        import_manager: &'a ImportManager,
        step_current: usize,
        step_last_application: usize,
    ) -> Result<Vec<Tag>, Error> {
        let mut plan = SubtableExecutionPlan::default();

        let runtime = RuntimeInformation {
            step_last_application,
            step_current,
            table_manager,
            import_manager,
            translation: self.translation.clone(),
        };

        let node_body = self.body.create_plan(&mut plan, &runtime).await;

        let node_aggregation = self
            .aggregation
            .as_ref()
            .map(|generator| generator.create_plan(&mut plan, node_body.clone(), &runtime));

        if let Some(node) = node_aggregation.clone() {
            plan.add_temporary_table(node, "Aggregation");
        }

        self.head
            .create_plan(&mut plan, node_body, node_aggregation, &runtime);

        table_manager.execute_plan(plan).await
    }
}

//! This module defines [GeneratorImport].

use std::collections::HashMap;

use nemo_physical::{
    management::execution_plan::{ColumnOrder, ExecutionNodeRef},
    tabular::operations::OperationTable,
};

use crate::{
    execution::planning::{
        RuntimeInformation,
        normalization::atom::import::ImportAtom,
        operations::union::{GeneratorUnion, UnionRange},
    },
    rule_model::components::{tag::Tag, term::primitive::variable::Variable},
    table_manager::{SubtableExecutionPlan, SubtableIdentifier},
};

/// Represents variable bindings generated by projection from the input table
#[derive(Debug, PartialEq, Eq)]
struct VariableBinding(Vec<Variable>);

impl VariableBinding {
    /// Return an iterator over the [Variable]s in this binding.
    pub fn iter(&self) -> impl Iterator<Item = &Variable> {
        self.0.iter()
    }
}

impl From<Vec<Variable>> for VariableBinding {
    fn from(value: Vec<Variable>) -> Self {
        Self(value)
    }
}

/// List of variable bindings and the index of the input tables they are derived from
#[derive(Debug, Default)]
struct VariableBindings(Vec<(VariableBinding, usize)>);

impl VariableBindings {
    /// Add a [VariableBinding] and return its index.
    pub fn add(&mut self, binding: VariableBinding, origin: usize) -> usize {
        match self.0.iter().position(|(existing, _)| *existing == binding) {
            Some(position) => position,
            None => {
                let result = self.0.len();
                self.0.push((binding, origin));

                result
            }
        }
    }
}

impl<'a> IntoIterator for &'a VariableBindings {
    type Item = (&'a VariableBinding, usize);

    type IntoIter = std::iter::Map<
        std::slice::Iter<'a, (VariableBinding, usize)>,
        fn(&'a (VariableBinding, usize)) -> (&'a VariableBinding, usize),
    >;

    fn into_iter(self) -> Self::IntoIter {
        self.0.iter().map(|(binding, origin)| (binding, *origin))
    }
}

/// Represents either a bound or free atom position
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
enum BindingPatternElement {
    /// Variable appears in the input nodes
    Bound,
    /// Variable does not appear in the input nodes
    Free,
}

/// Pattern of bound and free variable positions of an import atom
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct BindingPattern {
    /// Predicate of the import atom
    predicate: Tag,
    /// Binding pattern
    pattern: Vec<BindingPatternElement>,
    /// Indices of bound positions represented by this pattern
    ///
    /// None if this represents the whole pattern
    subset: Option<Vec<usize>>,
}

impl BindingPattern {
    /// For a given [ImportAtom],
    /// calculate all [BindingPattern] and return them together with
    /// the corresponding [VariableBinding] and the input index it originated from.
    pub fn new(input: &[Vec<Variable>], atom: &ImportAtom) -> Vec<(Self, VariableBinding, usize)> {
        let predicate = atom.predicate();

        let pattern = atom
            .variables()
            .map(|variable| {
                match input
                    .iter()
                    .flat_map(|variables| variables.iter())
                    .position(|input_variable| input_variable == variable)
                {
                    Some(_) => BindingPatternElement::Bound,
                    None => BindingPatternElement::Free,
                }
            })
            .collect::<Vec<_>>();

        let bound_variables = atom
            .variables()
            .zip(pattern.iter())
            .filter_map(|(variable, element)| match element {
                BindingPatternElement::Bound => Some(variable.clone()),
                BindingPatternElement::Free => None,
            })
            .collect::<Vec<_>>();

        let subsets = input
            .iter()
            .map(|input_variables| {
                input_variables
                    .iter()
                    .filter_map(|variable| {
                        bound_variables.iter().position(|bound| bound == variable)
                    })
                    .collect::<Vec<_>>()
            })
            .collect::<Vec<_>>();

        let mut result = Vec::default();

        for subset in subsets {
            if subset.is_empty() {
                continue;
            }

            let binding = VariableBinding::from(
                subset
                    .iter()
                    .map(|&index| bound_variables[index].clone())
                    .collect::<Vec<_>>(),
            );

            let origin = input
                .iter()
                .position(|variables| variables.contains(&bound_variables[subset[0]]))
                .expect("bound variables must appear in input");

            let pattern = Self {
                predicate: predicate.clone(),
                pattern: pattern.clone(),
                subset: Some(subset),
            };

            result.push((pattern, binding, origin));
        }

        if result.len() == 1 {
            result[0].0.subset = None;
        }

        result
    }

    /// Name of the table containing the import bindings for this pattern.
    pub fn name(&self) -> String {
        let mut name = format!("__IMPORT_{}_", self.predicate);

        for element in &self.pattern {
            match element {
                BindingPatternElement::Bound => name.push('b'),
                BindingPatternElement::Free => name.push('f'),
            }
        }

        if let Some(subset) = self.subset.as_ref() {
            let subset_string = format!(
                "_{}",
                subset
                    .iter()
                    .map(ToString::to_string)
                    .collect::<Vec<_>>()
                    .join(",")
            );

            name.push_str(&subset_string);
        }

        name
    }

    /// Arity of the table containing the import bindings for this pattern.
    pub fn arity(&self) -> usize {
        if let Some(subset) = &self.subset {
            subset.len()
        } else {
            self.pattern
                .iter()
                .filter(|element| matches!(element, BindingPatternElement::Bound))
                .count()
        }
    }
}

/// Generator of import nodes in execution plans
#[derive(Debug)]
pub struct GeneratorImport {
    /// List of [VariableBinding]s that are derived from the input tables
    bindings: VariableBindings,
    /// All [BindingPattern]s and
    patterns: HashMap<BindingPattern, Vec<usize>>,
    ///
    atoms: Vec<(ImportAtom, Vec<BindingPattern>)>,
    ///
    import_predicates: HashMap<Tag, Vec<usize>>,
}

impl GeneratorImport {
    /// Create a new [GeneratorImport].
    pub fn new(input_variables: Vec<Vec<Variable>>, import_atoms: &[ImportAtom]) -> Self {
        let mut bindings = VariableBindings::default();
        let mut patterns = HashMap::<BindingPattern, Vec<usize>>::default();
        let mut atoms = Vec::<(ImportAtom, Vec<BindingPattern>)>::default();
        let mut import_predicates = HashMap::<Tag, Vec<usize>>::default();

        for (atom_index, atom) in import_atoms.into_iter().enumerate() {
            let binding_patterns = BindingPattern::new(&input_variables, &atom);

            import_predicates
                .entry(atom.predicate())
                .or_default()
                .push(atom_index);

            atoms.push((
                atom.clone(),
                binding_patterns
                    .iter()
                    .map(|(pattern, _, _)| pattern.clone())
                    .collect::<Vec<_>>(),
            ));

            for (pattern, binding, origin) in binding_patterns {
                let binding_index = bindings.add(binding, origin);

                patterns.entry(pattern).or_default().push(binding_index);
            }
        }

        Self {
            bindings,
            patterns,
            atoms,
            import_predicates,
        }
    }

    /// Return an iterator over all special predicates used in this generator.
    pub fn special_predicates(&self) -> impl Iterator<Item = (Tag, usize)> {
        self.patterns
            .keys()
            .map(|pattern| (Tag::new(pattern.name()), pattern.arity()))
    }

    /// Create execution plan nodes
    /// that compute the inputs of the binding tables
    /// by projecting the relevant columns from the input nodes.
    ///
    /// Returns a list of [ExecutionNodeRef] where each nodes
    /// corresponds to a [VariableBinding] in `self.bindings`.
    fn create_binding_inputs(
        &self,
        plan: &mut SubtableExecutionPlan,
        input_nodes: Vec<ExecutionNodeRef>,
        runtime: &RuntimeInformation,
    ) -> Vec<ExecutionNodeRef> {
        let mut result = Vec::<ExecutionNodeRef>::default();

        for (binding, origin) in &self.bindings {
            let markers_binding = runtime.translation.operation_table(binding.iter());

            let node_projection = plan
                .plan_mut()
                .projectreorder(markers_binding.clone(), input_nodes[origin].clone());
            result.push(node_projection.clone());
        }

        result
    }

    /// Create execution plan nodes
    /// that compute the bindings for the imports.
    ///
    /// Returns a [HashMap] mapping each [BindingPattern]
    /// to a pair of [ExecutionNodeRef]s
    /// such that the first entry represents the "old" bindings
    /// and the second entry represents the "new" bindings.
    fn create_import_bindings(
        &self,
        plan: &mut SubtableExecutionPlan,
        binding_inputs: Vec<ExecutionNodeRef>,
        runtime: &RuntimeInformation,
    ) -> HashMap<BindingPattern, (ExecutionNodeRef, ExecutionNodeRef)> {
        let mut result = HashMap::default();

        for (pattern, inputs) in &self.patterns {
            let predicate = Tag::new(pattern.name());

            let input_tables = inputs
                .iter()
                .map(|&input| binding_inputs[input].clone())
                .collect::<Vec<_>>();
            let node_current_bindings = plan
                .plan_mut()
                .union(OperationTable::default(), input_tables);

            let node_old_bindings =
                GeneratorUnion::new_unmarked(predicate.clone(), UnionRange::All)
                    .create_plan(plan, runtime);

            let node_new_bindings = plan
                .plan_mut()
                .subtract(node_current_bindings, vec![node_old_bindings.clone()]);

            plan.add_permanent_table(
                node_new_bindings.clone(),
                "Import Bindings",
                "Import Bindings",
                SubtableIdentifier::new(predicate, runtime.step_current),
            );

            result.insert(pattern.clone(), (node_old_bindings, node_new_bindings));
        }

        result
    }

    /// Create execution plan nodes
    /// that are responsible for actually requesting the imported facts.
    ///
    /// Returns a list of [ExecutionNodeRef] where each node
    /// represents the imported table, and is associated with each entry
    /// in `self.atoms`.
    async fn create_imports<'a>(
        &self,
        plan: &mut SubtableExecutionPlan,
        bindings: HashMap<BindingPattern, (ExecutionNodeRef, ExecutionNodeRef)>,
        runtime: &RuntimeInformation<'a>,
    ) -> Vec<ExecutionNodeRef> {
        let mut result = Vec::default();

        for (atom, patterns) in &self.atoms {
            let provider = runtime
                .import_manager
                .table_provider_from_handler(&atom.handler())
                .await
                .expect("imports are validated during rule construction");

            let pattern_bindings = patterns.iter().map(|pattern| bindings.get(pattern).expect("construction of this generator ensures that all possible patterns appear in this map").clone()).collect::<Vec<_>>();
            let markers_atom = runtime.translation.operation_table(atom.variables());

            let node_import = plan
                .plan_mut()
                .import(markers_atom, pattern_bindings, provider);

            result.push(node_import);
        }

        result
    }

    /// Create execution plan nodes
    /// that combine each individual imports into one table for each import predicate
    fn consolidate_imports(
        &self,
        plan: &mut SubtableExecutionPlan,
        imports: Vec<ExecutionNodeRef>,
        runtime: &RuntimeInformation,
    ) {
        for (predicate, tables) in &self.import_predicates {
            let node_import = plan.plan_mut().union(
                OperationTable::default(),
                tables
                    .iter()
                    .map(|&table| imports[table].clone())
                    .collect::<Vec<_>>(),
            );

            let import_table_name = runtime.table_manager.generate_table_name(
                predicate,
                &ColumnOrder::default(),
                runtime.step_current - 1,
            );

            plan.add_permanent_table(
                node_import,
                "Rule Import",
                &import_table_name,
                SubtableIdentifier::new(predicate.clone(), runtime.step_current - 1),
            );
        }
    }

    /// Append this operation to the plan.
    pub async fn create_plan<'a>(
        &self,
        plan: &mut SubtableExecutionPlan,
        input_nodes: Vec<ExecutionNodeRef>,
        runtime: &RuntimeInformation<'a>,
    ) {
        let nodes_binding_inputs = self.create_binding_inputs(plan, input_nodes, runtime);
        let nodes_import_bindings =
            self.create_import_bindings(plan, nodes_binding_inputs, runtime);
        let nodes_imports = self
            .create_imports(plan, nodes_import_bindings, runtime)
            .await;

        self.consolidate_imports(plan, nodes_imports, runtime);
    }
}

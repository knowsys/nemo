//! This module defines [GeneratorImport].

use std::collections::HashMap;

use indexmap::IndexSet;
use nemo_physical::{
    management::execution_plan::{ColumnOrder, ExecutionNodeRef},
    tabular::operations::OperationTable,
};

use crate::{
    execution::planning::{
        RuntimeInformation,
        normalization::{atom::import::ImportAtom, operation::Operation},
        operations::{
            filter::GeneratorFilter,
            union::{GeneratorUnion, UnionRange},
        },
    },
    io::formats::Import,
    rule_model::components::{tag::Tag, term::primitive::variable::Variable},
    table_manager::{SubtableExecutionPlan, SubtableIdentifier},
};

/// Represents variable bindings generated by projection from the input table
#[derive(Debug, PartialEq, Eq)]
struct VariableBinding(Vec<Variable>);

impl VariableBinding {
    /// Return an iterator over the [Variable]s in this binding.
    pub fn iter(&self) -> impl Iterator<Item = &Variable> {
        self.0.iter()
    }
}

impl From<Vec<Variable>> for VariableBinding {
    fn from(value: Vec<Variable>) -> Self {
        Self(value)
    }
}

/// List of variable bindings and the index of the input tables they are derived from
#[derive(Debug, Default)]
struct VariableBindings(Vec<(VariableBinding, usize)>);

impl VariableBindings {
    /// Add a [VariableBinding] and return its index.
    pub fn add(&mut self, binding: VariableBinding, origin: usize) -> usize {
        match self.0.iter().position(|(existing, _)| *existing == binding) {
            Some(position) => position,
            None => {
                let result = self.0.len();
                self.0.push((binding, origin));

                result
            }
        }
    }
}

impl<'a> IntoIterator for &'a VariableBindings {
    type Item = (&'a VariableBinding, usize);

    type IntoIter = std::iter::Map<
        std::slice::Iter<'a, (VariableBinding, usize)>,
        fn(&'a (VariableBinding, usize)) -> (&'a VariableBinding, usize),
    >;

    fn into_iter(self) -> Self::IntoIter {
        self.0.iter().map(|(binding, origin)| (binding, *origin))
    }
}

/// Represents either a bound or free atom position
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
enum BindingPatternElement {
    /// Variable appears in the input nodes
    Bound,
    /// Variable does not appear in the input nodes
    Free,
}

/// Pattern of bound and free variable positions of an import atom
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct BindingPattern {
    /// Predicate of the import atom
    predicate: Tag,
    /// Binding pattern
    pattern: Vec<BindingPatternElement>,
    /// Indices of bound positions represented by this pattern
    ///
    /// None if this represents the whole pattern
    subset: Option<Vec<usize>>,
}

impl BindingPattern {
    /// For a given [ImportAtom],
    /// calculate all [BindingPattern] and return them together with
    /// the corresponding [VariableBinding] and the input index it originated from.
    pub fn new(input: &[Vec<Variable>], atom: &ImportAtom) -> Vec<(Self, VariableBinding, usize)> {
        let predicate = atom.predicate();

        let pattern = atom
            .variables()
            .map(|variable| {
                match input
                    .iter()
                    .flat_map(|variables| variables.iter())
                    .position(|input_variable| input_variable == variable)
                {
                    Some(_) => BindingPatternElement::Bound,
                    None => BindingPatternElement::Free,
                }
            })
            .collect::<Vec<_>>();

        let bound_variables = atom
            .variables()
            .zip(pattern.iter())
            .filter_map(|(variable, element)| match element {
                BindingPatternElement::Bound => Some(variable.clone()),
                BindingPatternElement::Free => None,
            })
            .collect::<Vec<_>>();

        let subsets = input
            .iter()
            .map(|input_variables| {
                let mut subset = input_variables
                    .iter()
                    .filter_map(|variable| {
                        bound_variables.iter().position(|bound| bound == variable)
                    })
                    .collect::<Vec<_>>();

                subset.sort();
                subset
            })
            .collect::<Vec<_>>();

        let mut result = Vec::default();

        for subset in subsets {
            if subset.is_empty() {
                continue;
            }

            let binding = VariableBinding::from(
                subset
                    .iter()
                    .map(|&index| bound_variables[index].clone())
                    .collect::<Vec<_>>(),
            );

            let origin = input
                .iter()
                .position(|variables| variables.contains(&bound_variables[subset[0]]))
                .expect("bound variables must appear in input");

            let pattern = Self {
                predicate: predicate.clone(),
                pattern: pattern.clone(),
                subset: Some(subset),
            };

            result.push((pattern, binding, origin));
        }

        if result.len() == 1 {
            result[0].0.subset = None;
        }

        result
    }

    /// Name of the table containing the import bindings for this pattern.
    pub fn name(&self) -> String {
        let mut name = format!("__IMPORT_{}_", self.predicate);

        for element in &self.pattern {
            match element {
                BindingPatternElement::Bound => name.push('b'),
                BindingPatternElement::Free => name.push('f'),
            }
        }

        if let Some(subset) = self.subset.as_ref() {
            let subset_string = format!(
                "_{}",
                subset
                    .iter()
                    .map(ToString::to_string)
                    .collect::<Vec<_>>()
                    .join(",")
            );

            name.push_str(&subset_string);
        }

        name
    }

    /// Arity of the table containing the import bindings for this pattern.
    pub fn arity(&self) -> usize {
        if let Some(subset) = &self.subset {
            subset.len()
        } else {
            self.pattern
                .iter()
                .filter(|element| matches!(element, BindingPatternElement::Bound))
                .count()
        }
    }
}

/// Combination of all subsets of a [BindingPattern]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct ProductBinding {
    /// Predicate of the associated import atom
    predicate: Tag,
    /// Arity of the associated import atom
    output_arity: usize,

    /// Individual patterns
    patterns: Vec<BindingPattern>,
}

impl ProductBinding {
    /// Create a new [ProductBinding].
    pub fn new(predicate: Tag, output_arity: usize) -> Self {
        Self {
            predicate,
            output_arity,
            patterns: Vec::default(),
        }
    }

    /// Add a [BindingPattern].
    pub fn push(&mut self, pattern: BindingPattern) {
        self.patterns.push(pattern);
    }

    /// Return an iterator over the individual [BindingPattern]s.
    pub fn iter(&self) -> impl Iterator<Item = &BindingPattern> {
        self.patterns.iter()
    }

    /// Return the predicate associated with this pattern.
    pub fn predicate(&self) -> &Tag {
        &self.predicate
    }

    /// For each factor return the list of bound positions.
    pub fn bound_positions(&self) -> Vec<Vec<usize>> {
        let mut result = Vec::default();

        for pattern in self.iter() {
            let mut bound_positions = pattern
                .pattern
                .iter()
                .enumerate()
                .filter_map(|(index, element)| match element {
                    BindingPatternElement::Bound => Some(index),
                    BindingPatternElement::Free => None,
                })
                .collect::<Vec<_>>();

            if let Some(subset) = &pattern.subset {
                bound_positions = subset
                    .iter()
                    .map(|&index| bound_positions[index])
                    .collect::<Vec<_>>();
            }

            result.push(bound_positions);
        }

        result
    }

    /// Return the number of
    pub fn output_arity(&self) -> usize {
        self.output_arity
    }
}

/// Generator of import nodes in execution plans
#[derive(Debug)]
pub struct GeneratorImport {
    /// List of [VariableBinding]s that are derived from the input tables
    bindings: VariableBindings,
    /// Associates for each [BindingPattern]s a list of indices
    /// pointing to `bindings`, indicating that this pattern
    /// can be constructed using the respective bindings (for distinct positions)
    patterns: HashMap<BindingPattern, Vec<usize>>,
    /// List of [ProductBinding] where each results in a new import
    imports: IndexSet<ProductBinding>,
    /// Maps [ProductBinding] (identified by their index in the [IndexSet])
    /// to a [GeneratorFilter]
    import_filters: HashMap<usize, GeneratorFilter>,
    /// Associates a predicate with a [Import]
    ///
    /// TODO: This assumes that each predicate is associated with exactly one [Import]
    /// but every [ImportAtom] (with the same predicate) might have different [Import]s.
    handlers: HashMap<Tag, Import>,

    /// Associates for each imported predicate
    /// a list of indices pointing to `imports`
    predicates: HashMap<Tag, Vec<usize>>,
}

impl GeneratorImport {
    /// Create a new [GeneratorImport].
    ///
    /// This function consumes [Operation]s from `operations`
    /// if they can be directly evaluated on a positive or negative [ImportAtom].
    pub fn new(
        input_variables: Vec<Vec<Variable>>,
        positive_import_atoms: &[ImportAtom],
        negative_import_atoms: &[ImportAtom],
        operations: &mut Vec<Operation>,
    ) -> Self {
        let mut bindings = VariableBindings::default();
        let mut patterns = HashMap::<BindingPattern, Vec<usize>>::default();
        let mut imports = IndexSet::<ProductBinding>::default();
        let mut import_filters = HashMap::<usize, GeneratorFilter>::default();
        let mut predicates = HashMap::<Tag, Vec<usize>>::default();
        let mut handlers = HashMap::default();

        for atom in positive_import_atoms.iter().chain(negative_import_atoms) {
            let binding_patterns = BindingPattern::new(&input_variables, atom);

            let mut product_pattern = ProductBinding::new(atom.predicate(), atom.arity());

            for (pattern, binding, origin) in binding_patterns {
                let binding_index = bindings.add(binding, origin);

                patterns
                    .entry(pattern.clone())
                    .or_default()
                    .push(binding_index);
                product_pattern.push(pattern);
            }

            let (import_index, _) = imports.insert_full(product_pattern);

            let filter = GeneratorFilter::new(atom.variables_cloned(), operations).or_none();
            if let Some(filter) = filter {
                import_filters.insert(import_index, filter);
            }

            predicates
                .entry(atom.predicate())
                .or_default()
                .push(import_index);

            handlers.insert(atom.predicate(), atom.handler());
        }

        Self {
            bindings,
            patterns,
            imports,
            import_filters,
            handlers,
            predicates,
        }
    }

    /// Return an iterator over all special predicates used in this generator.
    pub fn special_predicates(&self) -> impl Iterator<Item = (Tag, usize)> {
        self.patterns
            .keys()
            .map(|pattern| (Tag::new(pattern.name()), pattern.arity()))
    }

    /// Create execution plan nodes
    /// that compute the inputs of the binding tables
    /// by projecting the relevant columns from the input nodes.
    ///
    /// Returns a list of [ExecutionNodeRef] where each nodes
    /// corresponds to a [VariableBinding] in `self.bindings`.
    fn create_binding_inputs(
        &self,
        plan: &mut SubtableExecutionPlan,
        input_nodes: Vec<ExecutionNodeRef>,
        runtime: &RuntimeInformation,
    ) -> Vec<ExecutionNodeRef> {
        let mut result = Vec::<ExecutionNodeRef>::default();

        for (binding, origin) in &self.bindings {
            let markers_binding = runtime.translation.operation_table(binding.iter());

            let node_projection = plan
                .plan_mut()
                .projectreorder(markers_binding.clone(), input_nodes[origin].clone());
            result.push(node_projection.clone());
        }

        result
    }

    /// Create execution plan nodes
    /// that compute the bindings for the imports.
    ///
    /// Returns a [HashMap] mapping each [BindingPattern]
    /// to a pair of [ExecutionNodeRef]s
    /// such that the first entry represents the "old" bindings
    /// and the second entry represents the "new" bindings.
    fn create_import_bindings(
        &self,
        plan: &mut SubtableExecutionPlan,
        binding_inputs: Vec<ExecutionNodeRef>,
        runtime: &RuntimeInformation,
    ) -> HashMap<BindingPattern, (ExecutionNodeRef, ExecutionNodeRef)> {
        let mut result = HashMap::default();

        for (pattern, inputs) in &self.patterns {
            let predicate = Tag::new(pattern.name());
            let arity = pattern.arity();
            let markers = OperationTable::new_unique(arity);

            let input_tables = inputs
                .iter()
                .map(|&input| binding_inputs[input].clone())
                .collect::<Vec<_>>();

            let node_current_bindings = plan.plan_mut().union(markers.clone(), input_tables);

            let mut node_old_bindings =
                GeneratorUnion::new_unmarked(predicate.clone(), UnionRange::All)
                    .create_plan(plan, runtime);
            node_old_bindings.set_markers(markers);

            let node_new_bindings = plan
                .plan_mut()
                .subtract(node_current_bindings, vec![node_old_bindings.clone()]);

            plan.add_permanent_table(
                node_new_bindings.clone(),
                "Import Bindings",
                "Import Bindings",
                SubtableIdentifier::new(predicate, runtime.step_current),
            );

            result.insert(pattern.clone(), (node_old_bindings, node_new_bindings));
        }

        result
    }

    /// Create execution plan nodes
    /// that are responsible for actually requesting the imported facts.
    ///
    /// Returns a list of [ExecutionNodeRef] where each node
    /// represents the imported table, and is associated with each entry
    /// in `self.atoms`.
    async fn create_imports<'a>(
        &self,
        plan: &mut SubtableExecutionPlan,
        bindings: HashMap<BindingPattern, (ExecutionNodeRef, ExecutionNodeRef)>,
        runtime: &RuntimeInformation<'a>,
    ) -> Vec<ExecutionNodeRef> {
        let mut result = Vec::default();

        for (import_index, import) in self.imports.iter().enumerate() {
            let handler = self.handlers.get(import.predicate()).expect("construction of this generator ensures that every import predicate is associated with a handler");

            let provider = runtime
                .import_manager
                .table_provider_from_handler(handler)
                .await
                .expect("imports are validated during rule construction");

            let pattern_bindings = import.iter().map(|pattern| bindings.get(pattern).expect("construction of this generator ensures that all possible patterns appear in this map").clone()).collect::<Vec<_>>();

            let mut node_import = plan.plan_mut().import(
                OperationTable::default(),
                import.bound_positions(),
                import.output_arity(),
                pattern_bindings,
                provider,
            );

            if let Some(filter) = self.import_filters.get(&import_index) {
                node_import = filter.create_plan(plan, node_import, runtime);
            }

            result.push(node_import);
        }

        result
    }

    /// Create execution plan nodes
    /// that combine each individual imports into one table for each import predicate
    fn consolidate_imports(
        &self,
        plan: &mut SubtableExecutionPlan,
        imports: Vec<ExecutionNodeRef>,
        runtime: &RuntimeInformation,
    ) -> HashMap<Tag, ExecutionNodeRef> {
        let mut result = HashMap::default();

        for (predicate, tables) in &self.predicates {
            let markers = tables
                .first()
                .map(|&table| imports[table].markers_cloned())
                .unwrap_or_default();

            let node_import = plan.plan_mut().union(
                markers,
                tables
                    .iter()
                    .map(|&table| imports[table].clone())
                    .collect::<Vec<_>>(),
            );

            let import_table_name = runtime.table_manager.generate_table_name(
                predicate,
                &ColumnOrder::default(),
                runtime.step_current - 1,
            );

            plan.add_permanent_table(
                node_import.clone(),
                "Rule Import",
                &import_table_name,
                SubtableIdentifier::new(predicate.clone(), runtime.step_current - 1),
            );

            result.insert(predicate.clone(), node_import);
        }

        result
    }

    /// Append this operation to the plan.
    pub async fn create_plan<'a>(
        &self,
        plan: &mut SubtableExecutionPlan,
        input_nodes: Vec<ExecutionNodeRef>,
        runtime: &RuntimeInformation<'a>,
    ) -> HashMap<Tag, ExecutionNodeRef> {
        let nodes_binding_inputs = self.create_binding_inputs(plan, input_nodes, runtime);
        let nodes_import_bindings =
            self.create_import_bindings(plan, nodes_binding_inputs, runtime);
        let nodes_imports = self
            .create_imports(plan, nodes_import_bindings, runtime)
            .await;

        self.consolidate_imports(plan, nodes_imports, runtime)
    }
}

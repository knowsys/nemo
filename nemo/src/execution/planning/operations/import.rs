//! This module defines [GeneratorImport].

//! Generator for incremental import nodes.

use std::collections::{HashMap, HashSet};

use itertools::Itertools;
use nemo_physical::management::execution_plan::{ColumnOrder, ExecutionNodeRef};

use crate::{
    execution::planning::{
        RuntimeInformation,
        analysis::variable_order::VariableOrder,
        normalization::atom::import::ImportAtom,
        operations::union::{GeneratorUnion, UnionRange},
    },
    rule_model::components::{tag::Tag, term::primitive::variable::Variable},
    table_manager::{SubtableExecutionPlan, SubtableIdentifier},
};

/// Represents variable bindings generated by projection from the input table
#[derive(Debug, PartialEq, Eq)]
struct VariableBinding(pub Vec<Variable>);

/// Represents a list of [VariableBinding]s
#[derive(Debug, Default)]
struct VariableBindings(pub Vec<VariableBinding>);

impl VariableBindings {
    /// Add a binding required by an [ImportAtom] to this list.
    /// Returns the position of the new or existing binding in the list.
    pub fn add(&mut self, input_variables: &[Variable], atom: &ImportAtom) -> usize {
        let variables = atom
            .variables()
            .filter(|variable| input_variables.contains(variable))
            .cloned()
            .collect::<Vec<_>>();

        if let Some(position) = self.0.iter().position(|binding| binding.0 == variables) {
            position
        } else {
            self.0.push(VariableBinding(variables));
            self.0.len() - 1
        }
    }
}

/// Generator of import nodes in execution plans
#[derive(Debug)]
pub struct GeneratorImport {
    /// Variable Order
    order: VariableOrder,
    /// Input variables
    input_variables: Vec<Variable>,

    /// Bindings
    bindings: VariableBindings,

    /// Atoms
    ///
    /// Maps a predicate to a list of body atoms (with that predicate)
    /// and the subset of variables that occur both in that atom
    /// and the input
    atoms: HashMap<Tag, Vec<(ImportAtom, usize)>>,

    /// Set of special atoms used in this generator
    predicates: HashSet<(Tag, usize)>,
}

impl GeneratorImport {
    /// Create a new [GeneratorImport].
    pub fn new(
        input_variables: Vec<Variable>,
        atoms: Vec<ImportAtom>,
        order: &VariableOrder,
    ) -> Self {
        let mut bindings = VariableBindings::default();
        let mut atom_map = HashMap::<Tag, Vec<(ImportAtom, usize)>>::default();
        let mut predicates = HashSet::<(Tag, usize)>::default();

        let mut variables = input_variables.iter().cloned().collect::<HashSet<_>>();

        for atom in atoms {
            variables.extend(atom.variables().cloned());

            let index = bindings.add(&input_variables, &atom);

            let special_predicate = Self::predicate_name(&atom, &input_variables);
            predicates.insert(special_predicate);

            atom_map
                .entry(atom.predicate())
                .or_default()
                .push((atom, index));
        }

        let order = order.restrict_to(&variables);

        Self {
            order,
            input_variables,
            bindings,
            atoms: atom_map,
            predicates,
        }
    }

    /// Compute the predicate name and arity for the binding table.
    fn predicate_name(atom: &ImportAtom, input: &[Variable]) -> (Tag, usize) {
        let mut name = format!("__IMPORT_{}_", atom.predicate().name());
        let mut arity = 0;

        for variable in atom.variables() {
            if input.iter().contains(variable) {
                arity += 1;
                name.push('b');
            } else {
                name.push('f');
            }
        }

        (Tag::new(name), arity)
    }

    /// Return an iterator over all special predicates used in this generator.
    pub fn special_predicates(&self) -> impl Iterator<Item = (Tag, usize)> {
        self.predicates.iter().cloned()
    }

    /// Return a list of variables
    /// appearing in the output after applying this generator.
    pub fn output_variables(&self) -> Vec<Variable> {
        self.order.as_ordered_list()
    }

    /// Create execution plan nodes responsible for producing
    /// the required biinding tables by projecting the relevant
    /// columns from the input node.
    fn create_binding_tables(
        &self,
        plan: &mut SubtableExecutionPlan,
        input_node: ExecutionNodeRef,
        runtime: &RuntimeInformation,
    ) -> Vec<ExecutionNodeRef> {
        let mut result = Vec::<ExecutionNodeRef>::default();

        for binding in &self.bindings.0 {
            let markers_binding = runtime.translation.operation_table(binding.0.iter());

            let node_projection = plan
                .plan_mut()
                .projectreorder(markers_binding.clone(), input_node.clone());
            result.push(node_projection.clone());
        }

        result
    }

    /// Create execution plan nodes that contain the (new) imported facts.
    ///
    /// Returns a [HashMap] that maps each pair of predicate and binding
    /// (identified by its index in the vector) to the execution plan node.
    async fn create_import_nodes<'a>(
        &self,
        plan: &mut SubtableExecutionPlan,
        input_node: ExecutionNodeRef,
        runtime: &RuntimeInformation<'a>,
    ) -> HashMap<(Tag, usize), ExecutionNodeRef> {
        let mut result = HashMap::<(Tag, usize), ExecutionNodeRef>::default();

        let binding_nodes = self.create_binding_tables(plan, input_node, runtime);

        for (predicate, atoms) in &self.atoms {
            let mut stored_binding_tables = HashSet::<Tag>::default();

            for (atom, index_binding) in atoms {
                let (binding_predicate, _arity) = Self::predicate_name(atom, &self.input_variables);

                if !stored_binding_tables.insert(binding_predicate.clone()) {
                    continue;
                }

                let node_bindings = binding_nodes[*index_binding].clone();

                let node_old_bindings = GeneratorUnion::new(
                    binding_predicate.clone(),
                    self.bindings.0[*index_binding].0.clone(),
                    UnionRange::All,
                )
                .create_plan(plan, runtime);

                let node_new_bindings = plan
                    .plan_mut()
                    .subtract(node_bindings, vec![node_old_bindings]);

                plan.add_permanent_table(
                    node_new_bindings.clone(),
                    "Import Bindings",
                    "Import Bindings",
                    SubtableIdentifier::new(binding_predicate, runtime.step_current),
                );

                let provider = runtime
                    .import_manager
                    .table_provider_from_handler(&atom.handler())
                    .await
                    .expect("invalid import");

                let markers_atom = runtime.translation.operation_table(atom.variables());
                let node_import =
                    plan.plan_mut()
                        .import(markers_atom, node_new_bindings.clone(), provider);

                result.insert((predicate.clone(), *index_binding), node_import);
            }
        }

        result
    }

    /// Append this operation to the plan.
    pub async fn create_plan<'a>(
        &self,
        plan: &mut SubtableExecutionPlan,
        input_node: ExecutionNodeRef,
        runtime: &RuntimeInformation<'a>,
    ) -> ExecutionNodeRef {
        let import_nodes = self
            .create_import_nodes(plan, input_node.clone(), runtime)
            .await;

        let mut join_nodes = vec![input_node.clone()];

        for (predicate, atoms) in &self.atoms {
            let mut nodes_new_imports = Vec::<ExecutionNodeRef>::default();
            let mut binding_new_imports = HashSet::<usize>::default();

            for (atom, index_binding) in atoms {
                let markers_atom = runtime.translation.operation_table(atom.variables());

                let node_old =
                    GeneratorUnion::new(atom.predicate(), atom.variables_cloned(), UnionRange::All)
                        .create_plan(plan, runtime);
                let node_new = import_nodes
                    .get(&(atom.predicate(), *index_binding))
                    .expect("error in `create_import_nodes`");

                if binding_new_imports.insert(*index_binding) {
                    nodes_new_imports.push(node_new.clone());
                }

                let node_all = plan
                    .plan_mut()
                    .union(markers_atom, vec![node_old, node_new.clone()]);
                join_nodes.push(node_all);
            }

            let node_union = plan
                .plan_mut()
                .union(nodes_new_imports[0].markers_cloned(), nodes_new_imports);
            let import_table_name = runtime.table_manager.generate_table_name(
                predicate,
                &ColumnOrder::default(),
                runtime.step_current - 1,
            );

            plan.add_permanent_table(
                node_union,
                "Rule Import",
                &import_table_name,
                SubtableIdentifier::new(predicate.clone(), runtime.step_current - 1),
            );
        }

        let markers_join = runtime.translation.operation_table(self.order.iter());

        plan.plan_mut().join(markers_join, join_nodes)
    }

    /// Returns `Some(self)` or `None` depending on whether this is a noop,
    /// i.e. does not affect the result.
    pub fn or_none(self) -> Option<Self> {
        if !self.atoms.is_empty() {
            Some(self)
        } else {
            None
        }
    }
}
